#!/bin/bash -e

if ! [[ -d installers ]]
then
    echo -e "\e[31m\e[1mERROR! This Script is intended to be run from installer's parent directory."
    exit 1
fi

# Coerence checks
mkdir -p "installers/localdev"
cat <<EOT > installers/localdev/.env
RAILS_ENV=production
RACK_ENV=production
RAILS_LOG_TO_STDOUT="true"
LANG=en_US.UTF-8
RAILS_SERVE_STATIC_FILES="true"
RAILS_RELATIVE_URL_ROOT="/"
SECRET_KEY_BASE=dh37rbf4c7clbry320b5y3t854y9tc4938nyrnl9
DATABASE_URL=postgres://postgres:dev@postgresql/ies?pool=5
REDIS_URL=redis://redis
SMTP_DELIVERY_METHOD=smtp
SMTP_ADDRESS=changeme@example.com
SMTP_USERNAME=changeme@example.com
SMTP_PASSWORD=changeme
EOT
cat <<EOT > installers/localdev/docker-compose.yml
version: "3.7"

networks:
    default:
      external:
        name: development

x-common-vars: &commmon-vars
    RAILS_ENV: "${RAILS_ENV:-production}"
    RACK_ENV: "${RACK_ENV:-production}"
    RAILS_LOG_TO_STDOUT: "${RAILS_LOG_TO_STDOUT:-true}"
    LANG: "${LANG:-en_US.UTF-8}"
    RAILS_SERVE_STATIC_FILES: "${RAILS_SERVE_STATIC_FILES:-true}"
    RAILS_RELATIVE_URL_ROOT: "${RAILS_RELATIVE_URL_ROOT:-/}"
    SECRET_KEY_BASE: "${SECRET_KEY_BASE:-dh37rbf4c7clbry320b4y3t854y9tc4938nyrnl9}"
    DATABASE_URL: "${DATABASE_URL:-postgres://postgres:dev@postgresql/ies?pool=5}"
    REDIS_URL: "${REDIS_URL:-redis://redis}"
    SMTP_DELIVERY_METHOD: "${SMTP_DELIVERY_METHOD:-smtp}"
    SMTP_ADDRESS: "${SMTP_ADDRESS:-changeme@example.com}"
    SMTP_USERNAME: "${SMTP_USERNAME:-changeme@example.com}"
    SMTP_PASSWORD: "${SMTP_PASSWORD:-changeme}"

services:
    store-be:
        build: .
        restart: always
        external_links:
        - postgresql
        - redis
        entrypoint: /bin/entrypoint.sh
        environment: 
            <<: *commmon-vars
        healthcheck:
            test: "${DOCKER_HEALTHCHECK_TEST:-curl --fail http://localhost:3000/}"
            interval: "60s"
            timeout: "3s"
            retries: 3
    store-be-sidekiq:
        build: .
        restart: always
        external_links:
        - postgresql
        - redis
        depends_on:
        - store-be
        entrypoint: /bin/entrypoint-sidekiq.sh
        environment: 
            <<: *commmon-vars
        healthcheck:
            test: "${DOCKER_HEALTHCHECK_TEST:-sidekiqmon|grep $(hostname)}"
            interval: "60s"
            timeout: "3s"
            retries: 3

EOT

if ! [ -f "installers/docker-compose.build.yml" ]
then
    cat <<EOT > installers/docker-compose.build.yml
version: "3.7"

services: 
  backend:
    build: 
      dockerfile: vendor/backend/Dockerfile
      context: ../.

  backend-sidekiq:
    build: 
      dockerfile: vendor/backend/Dockerfile
      context: ../.

EOT
fi

if ! [ -f "installers/docker-compose.yml" ]
then
    cat <<EOT > installers/docker-compose.yml
version: "3.7"

networks:
  default:
    external:
      name: \${NETWORK}

# These come from exported environment variables
# probably set in the shell script which handles 
# the up of the application.
x-vars: &vars
  ADMIN_EMAIL: admin@\${BASE_DOMAIN}
  ADMIN_PASSWORD: \${ADMIN_PASSWORD}
  BACKEND_DOMAIN: \${BACKEND_DOMAIN}
  BACKEND_URL: \${BACKEND_URL}
  FRONTEND_DOMAIN: \${FRONTEND_DOMAIN}
  FRONTEND_URL: \${FRONTEND_URL}
  BASE_DOMAIN: \${BASE_DOMAIN}
  COMPOSE_PROJECT_NAME: \${COMPOSE_PROJECT_NAME}
  DATABASE_PASSWORD: \${DATABASE_PASSWORD}
  DEFAULT_OUTGOING_EMAIL_DOMAIN: \${BASE_DOMAIN}
  DEFAULT_SENDER_EMAIL: mailer@\${BASE_DOMAIN}
  LANG: \${LANG}
  LETSENCRYPT_EMAIL: \${LETSENCRYPT_EMAIL}
  RACK_ENV: \${RACK_ENV}
  RAILS_ENV: \${RAILS_ENV}
  RAILS_LOG_TO_STDOUT: \${RAILS_LOG_TO_STDOUT}
  RAILS_RELATIVE_URL_ROOT: \${RAILS_RELATIVE_URL_ROOT}
  RAILS_SERVE_STATIC_FILES: \${RAILS_SERVE_STATIC_FILES}
  REDIS_PASSWORD: \${REDIS_PASSWORD}
  REDIS_URL: \${REDIS_URL}
  SECRET_KEY_BASE: ${SECRET_KEY_BASE}
  SMTP_ADDRESS: \${SMTP_ADDRESS}
  SMTP_DELIVERY_METHOD: \${SMTP_DELIVERY_METHOD}
  SMTP_PASSWORD: \${SMTP_PASSWORD}
  SMTP_USERNAME: \${SMTP_USERNAME}
  FE_SUBDOMAIN: \${FE_SUBDOMAIN}
  BE_SUBDOMAIN: \${BE_SUBDOMAIN}
  ALLOW_MULTISESSIONS: \${ALLOW_MULTISESSIONS}

services: 
  backend:
    image: \${IMAGE_TAG_BACKEND}
    restart: always
    external_links:
      - postgresql
      - redis
      - letsencrypt
    entrypoint: /bin/entrypoint.sh
    environment:
      <<: *vars
      DATABASE_URL: postgres://postgres:\${DATABASE_PASSWORD}@postgresql/\${COMPOSE_PROJECT_NAME}backend?pool=5
      VIRTUAL_HOST: \${BACKEND_DOMAIN}
      LETSENCRYPT_HOST: \${BACKEND_DOMAIN}
      VIRTUAL_PORT: 3000
    volumes:
      - /root/persistence/\${COMPOSE_PROJECT_NAME}/storage:/app/storage
      - /root/persistence/\${COMPOSE_PROJECT_NAME}/imports:/app/tmp/imports
    healthcheck:
      test: "\${DOCKER_HEALTHCHECK_TEST:-curl --fail http://localhost:3000/}"
      interval: "60s"
      timeout: "3s"
      retries: 3

  backend-sidekiq:
    image: \${IMAGE_TAG_BACKEND_SIDEKIQ}
    restart: always
    depends_on:
      - backend
    external_links: 
      - postgresql
      - redis
    entrypoint: /bin/entrypoint-sidekiq.sh
    environment:
      <<: *vars
      DATABASE_URL: postgres://postgres:\${DATABASE_PASSWORD}@postgresql/\${COMPOSE_PROJECT_NAME}backend?pool=5
    volumes:
      - /root/persistence/\${COMPOSE_PROJECT_NAME}/storage:/app/storage
      - /root/persistence/\${COMPOSE_PROJECT_NAME}/imports:/app/tmp/imports
    healthcheck:
      test: "\${DOCKER_HEALTHCHECK_TEST:-bundle exec sidekiqmon|grep \$(hostname)}"
      interval: "60s"
      timeout: "3s"
      retries: 3

EOT
fi

mkdir -p "vendor/backend"
if ! [ -f "vendor/backend/Dockerfile" ]
then
    cat <<EOT > vendor/backend/Dockerfile
FROM ruby:2.7.2

RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | (OUT=$(apt-key add - 2>&1) || echo $OUT) \
    && echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \
    && export DEBIAN_FRONTEND=noninteractive \
    && apt-key adv --refresh-keys --keyserver keyserver.ubuntu.com \
    && apt-get update && apt-get -y install \
        poppler-utils \
        libvips-tools \
        libvips-dev \
        imagemagick \
        docker-compose \
        software-properties-common \
        build-essential \
        freetds-dev \
        libcups2-dev \
        yarn \
        sudo \
        apt-utils \
        git \
        openssh-client \
        gnupg2 \
        iproute2 \
        procps \
        lsof \
        htop \
        net-tools \
        psmisc \
        wget \
        rsync \
        ca-certificates \
        unzip \
        zip \
        nano \
        vim-tiny \
        less \
        jq \
        lsb-release \
        apt-transport-https \
        dialog \
        libc6 \
        libgcc1 \
        libgssapi-krb5-2 \
        libicu[0-9][0-9] \
        liblttng-ust0 \
        libstdc++6 \
        zlib1g \
        locales \
        sudo \
        ncdu \
        man-db \
        strace \
        libssl1.1 \
        gridsite-clients \
        geoip-database \
        libgirepository1.0-dev \
    # Update
    && apt-get -y dist-upgrade --no-install-recommends \
    # Clean up
    && apt-get autoremove -y && apt-get clean -y && rm -rf /var/lib/apt/lists/*

# Copy the Rails Appplication leving out the .dockrignored file
RUN mkdir /app
WORKDIR /app
ADD . /app

# Add the entrypoints
COPY ./vendor/backend/entrypoint*.sh /bin/
RUN chmod +x /bin/entrypoint*.sh

# Install Rails dependecies
# Use libxml2, libxslt a packages from alpine for building nokogiri
RUN gem install bundler \
    && bundle config set without development test \
    && bundle config set deployment true \
    && bundle config build.nokogiri --use-system-libraries \
    && bundle install --jobs=8

# ARG RAILS_ENV
# ARG SECRET_KEY_BASE

# This means that RAILS_RELATIVE_URL will always be /, no suburi support by now
RUN yarn install --check-files \
    && SECRET_KEY_BASE=dummy RAILS_ENV=production DATABASE_URL=nulldb:fake bundle exec rails assets:precompile \
    && rm -rf tmp/cache/* /tmp/* \
    && yarn cache clean

EXPOSE 3000

EOT
fi

cat <<EOT > vendor/backend/entrypoint-sidekiq.sh
#!/bin/sh

cd /app

bundle exec sidekiq # -C config/sidekiq.yml

EOT

cat <<EOT > vendor/backend/entrypoint.sh
#!/bin/sh

cd /app

if ! bundle exec rails runner "ActiveRecord::Base.connection rescue exit 1"
then
    # Fare solo la prima volta
    bundle exec rails db:create >log/latest-startup.log 2>&1
fi

bundle exec rails db:migrate >>log/latest-startup.log 2>&1
bundle exec rails thecore:db:seed >>log/latest-startup.log 2>&1

rm -f tmp/pids/server.pid
bundle exec rails s -p 3000 -b '0.0.0.0'

exit 0
EOT

chmod +x vendor/backend/entrypoint*.sh

while read -p "Please provide the service name for where this will be installed, i.e. digitalocean: " SERVICE_NAME; do
    [[ $SERVICE_NAME ]] && [[ "${SERVICE_NAME}" =~ [a-z\.-_] ]] && break
done

while read -p "Please provide the customer name, i.e. alchemic: " CUSTOMER_NAME; do
    [[ $CUSTOMER_NAME ]] && [[ "${CUSTOMER_NAME}" =~ [a-z\.-_] ]] && break
done

echo "$SERVICE_NAME" > "/tmp/latest-service-name"
echo "$CUSTOMER_NAME" > "/tmp/latest-customer-name"

mkdir -p "installers/$SERVICE_NAME"

cd "installers/$SERVICE_NAME"

if [[ -f $CUSTOMER_NAME.env ]] || [[ -f "docker_host" ]]
then
    echo -e "\e[31m\e[1mERROR! config file $CUSTOMER_NAME.env or docker_host already exists, please remove it to create a new one. For security reasons I won't overwrite an already working config file.\e[0m"
else
    # Asking relevant information

    while read -p "Please provide an remote connection string for the deploy (i.e. ssh://root@66.21.34.152:22): " REMOTE_URL; do
        # '(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
        REGEX='ssh://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
        [[ $REMOTE_URL ]] && [[ "${REMOTE_URL}" =~ $REGEX ]] && break
    done
    echo "$REMOTE_URL" > "docker_host"

    # NAMING SECTION
    while read -p "Please provide a human readable Application Name, i.e. Thecore App: " APP_NAME; do
        [[ $APP_NAME ]] && break
    done
    while read -p "Please provide an identification string for the App. Only lowercase letters are allowed, i.e. thecore: " PROJECT_NAME; do
        [[ $PROJECT_NAME ]] && [[ "${PROJECT_NAME}" =~ [a-z] ]] && break
    done

    # DOMAIN SECTION
    while read -p "Please provide the domain for the App, i.e. thecore.com: " BASE_DOMAIN; do
        [[ $BASE_DOMAIN ]] && [[ "${BASE_DOMAIN}" =~ [a-z\.-_] ]] && break
    done
    while read -p "Please provide the subdomain for the Frontend, i.e. frontend: " FE_SUBDOMAIN; do
        [[ $FE_SUBDOMAIN ]] && [[ "${FE_SUBDOMAIN}" =~ [a-z\.-_] ]] && break
    done
    while read -p "Please provide the subdomain for the Backend, i.e. backend: " BE_SUBDOMAIN; do
        [[ $BE_SUBDOMAIN ]] && [[ "${BE_SUBDOMAIN}" =~ [a-z\.-_] ]] && break
    done
    while read -p "Please provide a valid email for admin user and Letsencrypt registration, i.e. admin@thecore.com: " ADMIN_EMAIL; do
        [[ $ADMIN_EMAIL ]] && [[ "${ADMIN_EMAIL}" =~ [a-z\.-_]@[a-z\.-_] ]] && break
    done

    # DOCKER SECTION
    while read -p "Please provide the Docker Network name this App will join, i.e. base_default: " NETWORK; do
        [[ $NETWORK ]] && break
    done

    # OTHER SERVICES SECTION
    while read -p "Please provide the Database Password of an accessible Postgresql instance: " DATABASE_PASSWORD; do
        [[ $DATABASE_PASSWORD ]] && break
    done
    while read -p "Please provide the Redis Password of an accessible REDIS instance: " REDIS_PASSWORD; do
        [[ $REDIS_PASSWORD ]] && break
    done

    # INTEGRATIONS SECTION
    while read -p "Can a user be allowed to login from different devices or is this a public event? [true,false]: " ALLOW_MULTISESSIONS; do
        [[ $ALLOW_MULTISESSIONS ]] && { [[ $ALLOW_MULTISESSIONS == "true" ]] || [[ $ALLOW_MULTISESSIONS == "false" ]] } && break
    done

    cat <<EOT > $CUSTOMER_NAME.env
# Common vars with base VARs (Better not to touch if already used)
DATABASE_PASSWORD=$DATABASE_PASSWORD
REDIS_PASSWORD=$REDIS_PASSWORD

# This App specific VARs (Don't touch absolutely)
SECRET_KEY_BASE=$(openssl rand -hex 64)
ADMIN_PASSWORD=$(openssl rand -hex 8)

# Derived vars (Maybe these can be touched)
APP_NAME=$APP_NAME
COMPOSE_PROJECT_NAME=$PROJECT_NAME
BASE_DOMAIN=$BASE_DOMAIN
FE_SUBDOMAIN=$FE_SUBDOMAIN
BE_SUBDOMAIN=$BE_SUBDOMAIN
LETSENCRYPT_EMAIL=$ADMIN_EMAIL
RAILS_ENV=production
RACK_ENV=production
RAILS_LOG_TO_STDOUT=true
LANG=en_US.UTF-8
RAILS_SERVE_STATIC_FILES=true
RAILS_RELATIVE_URL_ROOT=/
SMTP_DELIVERY_METHOD=smtp
SMTP_ADDRESS=$ADMIN_EMAIL
SMTP_USERNAME=$ADMIN_EMAIL
SMTP_PASSWORD=changeme

# Less frequently changed VARS
BACKEND_DOMAIN=${BE_SUBDOMAIN}.${BASE_DOMAIN}
BACKEND_URL=https://${BE_SUBDOMAIN}.${BASE_DOMAIN}
FRONTEND_DOMAIN=${FE_SUBDOMAIN}.${BASE_DOMAIN}
FRONTEND_URL=https://${FE_SUBDOMAIN}.${BASE_DOMAIN}
REDIS_URL=redis://:${REDIS_PASSWORD}@redis

NETWORK=$NETWORK

ALLOW_MULTISESSIONS=true
EOT
    cd ..
    docker-compose --env-file "$SERVICE_NAME/$CUSTOMER_NAME.env" config
    echo -e "\e[32m\e[1mCongratulations! Config file succesfully generated. Please run bin/up.sh on the production server to install this new application.\e[0m"
    echo "Please check the config file dump above to see if it's all right for the installation."
fi
